# Full Stack Node.js + React App with AKS Deployment

## Repository Structure

```
my-fullstack-app/
├── .github/
│   └── workflows/
│       └── deploy-to-aks.yml
├── backend/
│   ├── src/
│   │   └── server.js
│   ├── package.json
│   └── Dockerfile
├── frontend/
│   ├── src/
│   │   ├── App.js
│   │   └── index.js
│   ├── public/
│   │   └── index.html
│   ├── package.json
│   └── Dockerfile
├── k8s/
│   ├── backend-deployment.yaml
│   ├── backend-service.yaml
│   ├── frontend-deployment.yaml
│   └── frontend-service.yaml
└── README.md
```

---

## Backend Files

### `backend/package.json`

```json
{
  "name": "backend",
  "version": "1.0.0",
  "description": "Node.js API Backend",
  "main": "src/server.js",
  "scripts": {
    "start": "node src/server.js",
    "dev": "nodemon src/server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5"
  },
  "devDependencies": {
    "nodemon": "^3.0.1"
  }
}
```

### `backend/src/server.js`

```javascript
const express = require('express');
const cors = require('cors');

const app = express();
const PORT = process.env.PORT || 3001;

app.use(cors());
app.use(express.json());

app.get('/api/health', (req, res) => {
  res.json({ status: 'healthy', timestamp: new Date().toISOString() });
});

app.get('/api/message', (req, res) => {
  res.json({ message: 'Hello from Node.js backend on AKS!' });
});

app.listen(PORT, () => {
  console.log(`Backend server running on port ${PORT}`);
});
```

### `backend/Dockerfile`

```dockerfile
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY src ./src

EXPOSE 3001

CMD ["npm", "start"]
```

---

## Frontend Files

### `frontend/package.json`

```json
{
  "name": "frontend",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-scripts": "5.0.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": ["react-app"]
  },
  "browserslist": {
    "production": [">0.2%", "not dead", "not op_mini all"],
    "development": ["last 1 chrome version", "last 1 firefox version", "last 1 safari version"]
  },
  "proxy": "http://localhost:3001"
}
```

### `frontend/public/index.html`

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="Full Stack App on AKS" />
    <title>Full Stack App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>
```

### `frontend/src/index.js`

```javascript
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

### `frontend/src/App.js`

```javascript
import React, { useState, useEffect } from 'react';

function App() {
  const [message, setMessage] = useState('');
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetch('/api/message')
      .then(res => res.json())
      .then(data => {
        setMessage(data.message);
        setLoading(false);
      })
      .catch(err => {
        setError(err.message);
        setLoading(false);
      });
  }, []);

  return (
    <div style={{ 
      fontFamily: 'Arial, sans-serif', 
      maxWidth: '600px', 
      margin: '50px auto',
      padding: '20px',
      textAlign: 'center'
    }}>
      <h1>Full Stack App on AKS</h1>
      {loading && <p>Loading...</p>}
      {error && <p style={{ color: 'red' }}>Error: {error}</p>}
      {message && <p style={{ 
        fontSize: '20px', 
        color: '#007bff',
        padding: '20px',
        backgroundColor: '#f0f0f0',
        borderRadius: '8px'
      }}>{message}</p>}
    </div>
  );
}

export default App;
```

### `frontend/Dockerfile`

```dockerfile
# Build stage
FROM node:18-alpine as build

WORKDIR /app

COPY package*.json ./
RUN npm ci

COPY . ./
RUN npm run build

# Production stage
FROM nginx:alpine

COPY --from=build /app/build /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

### `frontend/nginx.conf`

```nginx
server {
    listen 80;
    server_name localhost;
    root /usr/share/nginx/html;
    index index.html;

    location / {
        try_files $uri $uri/ /index.html;
    }

    location /api {
        proxy_pass http://backend-service:3001;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
}
```

---

## Kubernetes Manifests

### `k8s/backend-deployment.yaml`

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  labels:
    app: backend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: ${ACR_NAME}.azurecr.io/backend:${IMAGE_TAG}
        ports:
        - containerPort: 3001
        env:
        - name: PORT
          value: "3001"
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /api/health
            port: 3001
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /api/health
            port: 3001
          initialDelaySeconds: 5
          periodSeconds: 5
```

### `k8s/backend-service.yaml`

```yaml
apiVersion: v1
kind: Service
metadata:
  name: backend-service
spec:
  selector:
    app: backend
  ports:
    - protocol: TCP
      port: 3001
      targetPort: 3001
  type: ClusterIP
```

### `k8s/frontend-deployment.yaml`

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  labels:
    app: frontend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: frontend
        image: ${ACR_NAME}.azurecr.io/frontend:${IMAGE_TAG}
        ports:
        - containerPort: 80
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 5
```

### `k8s/frontend-service.yaml`

```yaml
apiVersion: v1
kind: Service
metadata:
  name: frontend-service
spec:
  selector:
    app: frontend
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
  type: LoadBalancer
```

---

## GitHub Actions Workflow

### `.github/workflows/deploy-to-aks.yml`

```yaml
name: Deploy to AKS

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  ACR_NAME: myacrregistry
  RESOURCE_GROUP: my-resource-group
  CLUSTER_NAME: my-aks-cluster
  IMAGE_TAG: ${{ github.sha }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Login to Azure Container Registry
      run: |
        az acr login --name ${{ env.ACR_NAME }}

    - name: Build and push backend image
      run: |
        docker build -t ${{ env.ACR_NAME }}.azurecr.io/backend:${{ env.IMAGE_TAG }} ./backend
        docker push ${{ env.ACR_NAME }}.azurecr.io/backend:${{ env.IMAGE_TAG }}

    - name: Build and push frontend image
      run: |
        docker build -t ${{ env.ACR_NAME }}.azurecr.io/frontend:${{ env.IMAGE_TAG }} ./frontend
        docker push ${{ env.ACR_NAME }}.azurecr.io/frontend:${{ env.IMAGE_TAG }}

    - name: Set AKS context
      uses: azure/aks-set-context@v3
      with:
        resource-group: ${{ env.RESOURCE_GROUP }}
        cluster-name: ${{ env.CLUSTER_NAME }}

    - name: Deploy to AKS
      run: |
        # Replace placeholders in YAML files
        export ACR_NAME=${{ env.ACR_NAME }}
        export IMAGE_TAG=${{ env.IMAGE_TAG }}
        
        for file in k8s/*.yaml; do
          envsubst < $file | kubectl apply -f -
        done

    - name: Verify deployment
      run: |
        kubectl rollout status deployment/backend
        kubectl rollout status deployment/frontend
        kubectl get services
```

---

## Setup Instructions

### Prerequisites

1. **Azure Resources**:
   - Azure Container Registry (ACR)
   - Azure Kubernetes Service (AKS) cluster
   - Service Principal with permissions

2. **Create Azure Service Principal**:
```bash
az ad sp create-for-rbac --name "github-actions-sp" --role contributor \
  --scopes /subscriptions/{subscription-id}/resourceGroups/{resource-group} \
  --sdk-auth
```

3. **Configure GitHub Secrets**:
   - `AZURE_CREDENTIALS`: JSON output from service principal creation
   - Update workflow environment variables with your actual values

### Local Development

**Backend**:
```bash
cd backend
npm install
npm run dev
```

**Frontend**:
```bash
cd frontend
npm install
npm start
```

### Deploy to AKS

1. Push code to the `main` branch
2. GitHub Actions will automatically build and deploy
3. Get the external IP:
```bash
kubectl get service frontend-service
```

### Useful Commands

```bash
# View pods
kubectl get pods

# View logs
kubectl logs -f deployment/backend
kubectl logs -f deployment/frontend

# Scale deployment
kubectl scale deployment/backend --replicas=3

# Delete all resources
kubectl delete -f k8s/
```

---

## Architecture

- **Backend**: Node.js/Express API running on port 3001
- **Frontend**: React SPA served by Nginx
- **Nginx**: Proxies `/api` requests to backend service
- **AKS**: Manages container orchestration
- **ACR**: Stores Docker images
- **GitHub Actions**: CI/CD pipeline

## Notes

- Images are tagged with git commit SHA for traceability
- LoadBalancer service exposes frontend to the internet
- Backend is only accessible within the cluster (ClusterIP)
- Health checks ensure pods are ready before receiving traffic